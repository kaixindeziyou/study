# java基本语法

## 知识点

- **byte x=0;byte x1=9 byte x2=3; x=x1+x2; (不可取，因为等号右边是两个不确定的值，不知道运算之后会不会超出byte的范围)但是int类型的就没有这种限制，相加之后可能会变成负数。**
- **a++ 就是先a进行运算 a再自加 a的值会进行自存**
- **++a a先自加 然后在参与运算**
- **switch后那个括号里面可以选择的类型 int short byte char**
- **用switch语句时 他会先执行case然后在执行default无论他们的顺序**
- **当switch已经选择了语句后 如果这个语句没有break那么当他遇到语句便会执行不需要判断，直到遇到break或者大括号。**
- **if和switch的应用**
  - if:
    -  1.对具体的值进行判断。
    - 2.对区间进行判断。
    -  3.对运算结果是Boolean类型的表达式进行判断。
  - switch：
    - 1.对具体的值进行判断。
    - 2.值的个数通常是固定的。
    - 3.对于几个固定的值进行判断，建议使用switch语句，因为switch语句会将具体的答案都加进内存。效率相对高一点。
- **内存的划分**
  - 1.寄存器。
  - 2.本地方法区
  - 3.方法区。
  - 4.栈内存。
    - 储存的都是局部变量。 
    -   而且变量所属的作用域一旦结束，该变量就自动释放。
  - 5.堆内存
    - 储存的是数组和对象（数组就是对象）凡是new建立在堆中。   
    - 特点：
      - 1.每一个实体都有首地址值。
      - 2.堆内存中的每一个变量都有默认初始化值，根据类型的不同。整数是0，小数是0.0或0.0f，Boolean 是false char是'\u0000'   
      - 3.垃圾回收机制。
- **计算机底层都以补码的方式存储数据**
- **包名**：xxxyyyzzz类名
- **接口名**：XxxYyyZzz
- **变量名，方法名：**xxxYyyZzz
- **常量名：**XXX_YYY_ZZZ
- **从键盘获取值：**
  - 步骤：
  - 1.导包：import java.util.Scanner;
  - 2.Scanner的实例化：Scanner scan =new Scanner(System.in);
  - 3.调用Scanner类的相关方法（next()/nextXxx()），来获取指定类型的变量。注意：需要根据相应的方法来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchExce 导致程序终止。
- **将String字符串gander中的第一个字符拿出来**
  - char ganderChar = gander.charAt(0)；
- **判断isHandsome是不是"是”**
  - isHandsome.equa("是")
- **获取随机数：10-99**
  - double value = Math.random() // [0.0-1.0)
  - double value = Math.random() *90 +10// [10-100)
  - int value =(int )(Math.random() *90+10)//[10-99]*
  - *公式：[a,b]  :(int ) (Math.random()*(b-a+1)+a)
- **常用的权限修饰符**
  - public , private , 缺省 ，protected
- **可变个数形参:**
  - 形参： 数据类型 ... 变量名当调用可变个数形参的方法时，可以传入 0个，1个，2个.......
- 如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。
- 如果参数是引用数据类型，此时实参赋给形参的是实参储存数据的地址值。
- **this调用构造器**
  - 1.在我们类的构造器中，可以显示的使用“this.(形参列表)”方式，调用本类中指定的其他构造器。  
  -  2.构造器不能通过“this.(形参列表)”方式调用自己。 
  -   3.“this.(形参列表)”必须声明在构造器的首行。
  -    4.构造器内部，最多只能声明一个“this.(形参列表)”，用来调用其他构造器。
- **import 关键字的使用**
  - 1.在源文件中显式的使用import结构导入指定包下的类、接口。
  - 2.声明在包的声明和类的声明之间。
  - 3.如果需要导入多个结构，则并列写出即可。
  - 4.如果使用“xxx.* " 的方式，表示可以导入包下的所有结构。
  - 5.如果使用的类或接口是java.lang包下定义的，则可以省略import结构。
  - 6.如果使用的类或接口是本包下定义的，则可以省略import结构
  - 7.如果在源文件总，使用了不同包下的同名的类。则必须至少有一个类需要以全类名的方式显示。
  - 8.是用”xxx.*“方式表明可以调用xxx包下的所有结构，但是如果使用的是xxx子包下的结构，则仍需要导包。
  - 9.import static:导入指定类或接口中的静态结构：属性或方法。
- **super关键字：**
  - 1.super理解为：父类的  
  -  2.super可以用来调用：属性，方法，构造器   
  - 3.super的使用     
    - 我们可以在子类的方法或者在构造器中。通过使用“super.属性”或“super.方法”的方式，显式的调用     父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super.”     
    - 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用        “super.属性”的方式，表明调用的是父类中声明的属性。     
    - 特殊情况：当子类重写了父类的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用        “super.方法”的方式，表明调用的是父类中被重写的方法
- **4.super调用构造器**
  -   我们可以在子类的构造器中显式的使用”super(形参列表)“的方式，调用父类中声明的指定的构造器     
  - “super(形参列表)”的使用，必须声明在子类构造器的首行。     
  - 在类的构造器中 ，针对于“this（形参列表）”或“super(形参列表)”只能二选一，不能同时出现。     
  -  在构造器的首行没有显式的声明this（形参列表）或super（形参列表）则默认调用的是父类中空参的构造器：super（）;     
  - 在列的多个构造器中，至少有一个类的构造器中使用了“super（形参列表）”调用父类中的构造器。
- **java.lang.Object类**
  - 1.Object类是所有Java类的根父类
  - 2.如果在类的声明中未使用extends等关键字指明其父类，则默认父类为java.lang.Object类
  - **Object类中的 属性，方法 功能具有通用功能**
- **==和equals的区别**
  -    ==   
    - 可以使用在基本类型变量和应用数据类型变量中   
    - 如果比较的基本数据类型变量，比较两个变量数据是否相等（不一定类型要相同）   
    - 如果比较的是引用数据类型变量，比较两个对象的地址值是否相等，即两个引用是否指向同一个对象实体   
    - ==使用时必须保证左右两边变量类型一致。
  -  **equals（）**  
    -  1.是一个方法，而非运算符   
    - 2.只能适用于引用数据类型   
    - 3.Object类中equals（）的定义：  
    -  public booleaan equals(Object obj){
    - ​     return (this == obj); 
    -   }
  - **说明：**
    - Object类中定义的equals（）和==的作用是相同的：比较两个对象的地址值是否相等，即两个引用是否指向同一个对象实体
  - 4.像String，Date，File，包装类等都重写了Object类中equals（）方法。重写以后，比较的不是两个引用的地址   是否相同，而是比较两个对象的“实体内容”是否相同。
-   任何情况下，x.equlas(null) ，永远返回“false”   
- x.equals(和x不同类型的对象) 永远返回false
- **toString()方法**：
  - 当我们输出一个引用的时，实际上就是调用当前对象的toString()   像String，Date，File，包装类等都重写了toString方法   使得在调用toString（）时，返回“实体内容”信息
  - 自定义类也可以重写toString()方法，
- **包装类的使用：**
  - 1.Java提供了8中基本数据类型对应的包装类，使得基本数据类型具有类的特征。
  - 基本数据类型---->转换成包装类 调用 包装类的构造器
  - 包装类---->基本数据类型  ：调用包装类Xxx的xxxValue()
  - byte-Byte
  - char-Character
  - short-Short
  - int-Integer
  - double-Double
  - long-Long
  - boolean-Boolean
- **自动装箱与自动拆箱**
  - **包装类，基本数据类型--->String类型** 
    -   方法一：
      - int in1 = 10；
      - String str = 10 + “”；   
    - 方法二：
      - 调用String重载的valueOf(Xxx xxx);
  - **String--->包装类，基本数据类型**
  - 调用包装类的parseXxx(String s)
    Integer 内部定义了IntegerCache结构，IntegerCache中定义了Integer[]，保存了从-128到127范围内的整数。如果我们使用自动装箱的方式，给Integer 赋值的范围在-128到127内时，可以直接使用数组中的元素，目的，提高效率。
- **单例设计模式：**
  - 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。
  -   **饿汉式：**
    - 1.私有化类的构造器（外面就不可以直接创建对象了）  
    -  2.内部创建类的对象   
    - 3.要求此对象也必须声明为静态的（因为下面方法是静态的）   
    - 4.提供公共的静态的方法，返回类的对象
  -  **懒汉式：**  
    - 1.私有化类的构造器  
    - 2.声明当前类对象，没有初始化    
    - 3.此对象也必须声明为static的   
    - 4.声明pubic，static的返回当前类对象的方法（用if进行判断是否之前造过对象，没造过就造，造过就直接返回）
  - **区分饿汉式和懒汉式：**
    -   饿汉式：
      - 坏处：对象加载时间过长。           
      - 好处：饿汉式是线程安全的  
    - 懒汉式：
      - 好处：延迟对象的创建。           
      - 目前的写法的坏处：线程不安全。--->到多线程在修改。
- **代码块**
  - 1.代码块的作用：用来初始化类，对象。
  - 2.代码块如果有修饰的话，只能使用static
  - 3.分类：静态代码块，非静态代码块。
  - 静态代码块：
    - static{
    - }
    - 内部可以有输出语句，随着类的加载而执行，而且只执行一次。静态代码块内只能调用静态的属性和方法。
  - 非静态代码块：
    - {
    - }
    - 内部可以有输出语句随着对象的创建而执行，每创建一个对象，就执行一次。
    - 作用：可以在创建对象时，对对象的属性进行初始化。内部可以调用静态的属性方法，或非静态的 属性方法。
  - 可以定义多个代码块
  - 如果静态代码块之间，则执行顺序按照代码的位置
  - 如果是静态的和非静态则先执行静态，静态先加载呗。非静态之间，按代码位置
- 对象可以赋值的位置：
  - 1.默认初始化
  - 2.显示初始化
  - 3.构造器中初始化
  - 4.有了对象以后，可以通过“对象.属性”或“对象.方法”
  - 5.在代码块中赋值
- **fina关键字**
  - fina：最终的
  - 1.fina可以用来修饰的结构：类，方法，变
  - 2.fina用来修饰一个类   这个类不能再让其它类延续，不能再有子类了  er类比如：String类，System类，StringBff
  - 3.fina用来修饰方法：  表明此方法不能在重写  比如:object类中的getClass();
  - 4.fina来修饰一个变量：   此时的“变量”就称为常量了 
    -  4.1:final修饰属性，可以考虑的赋值位置有：显示初始化，代码块中初始化，构造器中初始化 
    -  4.2：final修饰局部变量       
      - 尤其是使用final来修饰形参时，表明此形参是一个常量，给常量形参赋值一个实参，一旦赋值以后就只能使用，不能改动
  - static final 用来修饰属性:全局常量。



## 重载

在同一个类中，允许存在一个以上的同名函数只要他们的参数个数或者参数类型不同即可。

特点：与返回值类型无关。

好处：方便于阅读，优化了程序设计。



## 封装

我们将属性xxx私有化（private）,同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值。

1. Java规定的四种权限：(从小到大排序)private（类内部） 、缺省（同一个包）、protected(不同包的子类)，public(同一个工程)。
2. 4种权限可以用来修饰类及类的内部结构：属性，方法，构造器，内部类。
3. 具体的，四种权限都可以用来修饰类的内部结构：。。。
   1.   修饰类的话，只能使用：缺省，public

**默认构造器的权限和类的权限相同**

当方法的形参和属性同名 要用"this.变量名"来区分



## 继承

 extends:延展，扩展。

- 继承性的好处：
  - 1.减少了代码的冗余，提高了代码的复用性。
  - 2.便于功能的扩展。
  - 3.为之后的多态性的使用，提供了前提。
- **继承性的格式**：class A extends B {} 
  -   A：子类，派生类，subclass.  
  -  B：父类，超类，基类，superclass
  -   体现：一旦子类A中继承父类B之后，子类A中就获取的父类B中声明的结构：属性，方法.   
  -   特别的父类中声明为private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。     只是因为封装性的影响，使得子类不能直接调用父类中的结构而已。
- **java中关于继承性的规定：**   
  - 1.一个父类可以有多个子类。   
  - 2.一个类只能有一个父类。（java中类的单继承性）  
  - 3.子父类是相对的概念，（直接父类，间接父类）（多层继承）。 
  - 4.子类直接继承的父类，称为直接父类。间接继承的父类称为：间接父类。   5.子类继承父类以后，就获取了直接父类以及所有简介父类中声明的属性和方法。
- 如果我们没有显示的声明一个类的父类的话，则此类继承于java.lang.Object类 



## 重写

1.  重写：子类继承父类以后 ，可以对父类中同名同参数的方法进行覆盖操作。  
2.  应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中同名同参数的方法时，实际执行的是子类重写父类的方法。  
3.  规定：     
   1. 子类重写的方法的**方法名**和参数列表和父类中被重写的相同  
   2.  子类重写的方法的**权限修饰符**不小于父类中被重写的方法的权限修饰符。     
      1. 特殊情况：子类不能重写父类中权限为private的方法   
   3.  返回值类型：      
      1.  如果父类中被重写的方法的返回值类型是void ，则子类重写的方法的返回值类型是void        
      2. 子类重写的方法返回值类型的可以是父类返回值类型的子类        
      3. 如果是基本数据类型 则必须一样。
   4.  throws 异常的类型：        
      1. 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

**子类和父类中的同名同参数的方法要么都声明为非static(考虑重写) ，要么都声明为static(不是重写)。**



## 多态

- **理解多态性**：
  - 可以理解为一个事物的多种形态。
- **何为多态性**：   
  - 对象的多态性：父类的引用指向子类的对象。（或子列的对象赋给父类的引用）
- **多态的使用：**
  - 虚拟方法调用   有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法
- **总结：**
- 编译，看左边。运行，看右边。
  - 对象的多态性，只适用于方法，不适用于属性。
  - 多态性是运行时行为
  - 重载-早绑定-静态绑定-他们的调用地址在编译期就被绑定了
  - 重写-晚绑定-动态绑定-直到方法调用的那一刻解释运行器才会确定所要调用的具体方法。
- **不能调用子类中所特有的方法**
  - 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型。导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。
- 如何才可以**调用子类特有的属性和方法。**
  - persion p2 = new man(); 
  - ​    <-------
  - **向上转型**：多态
  - man m1 = (man) p2; 
  - ​    <-------
  - **向下转型***
  - 使用强转时,可能会出现ClassCastException*
- **关键字 instanceof**
  - a instanceof A
  - 判断对象a是否是A的实例。如果是返回true，如果不是，返回false;
  - 使用情景：为了避免在向下转型时出现ClassCastException的异常 ，我们进行判断
  - 如果a instanceof A 返回true，则a instanceof B 也返回true 其中B是A的父类。
  - ==:对于引用数据类型，比较的是两个引用数据类型变量的地址值



## 抽象类

- 1.abstract：抽象的。
- 2.abstract可以用来修饰的结构：类，方法。
- 3.abstract 修饰类：抽象类  
  - 此类不能实例化，  
  - 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类实例化的全过程）  
  - 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作。
- 4.abstract修饰方法：抽象方法  
  - 包含抽象方法类一定是一个抽象类。反之，抽象类中可以没有抽象方法。  
  - 抽象方法只有方法的声明，没有方法。  
  - public abstract void eat();  
  - 若子类重写了父类中所有抽象方法后，此子类方可实例化。  
  - 若子类没有重写父类中所有的抽象方法，则此子列也是一个抽象类，用abstract修饰
- 5.abstract使用上的注意点：  
  -  abstract不能用来修饰属性，构造器等结构。
  -   abstract不能用来修饰私有方法，静态方法，fina的方法 ,final的类。
  - 抽象类的匿名子类：

## 接口

- **接口的使用：**
- 1.接口使用interfance关键字来定义。
- 2.Java中，接口和类是两个并列的结构。
- 3.如何定义接口：定义接口中的成员  
  - 3.1- JDK 7及以前：     
    - 只能定义全局常量和抽象方法。     
    - 全局常量public static final 但是书写时可以省略不写，默认有     
    - 抽象方法public abstract 的
  - 3.2- JDK8   
    -   除了定义全局常量和抽象方法之外，还可以定义静态方法，默认方法（略）。
- 4.接口中不能定义构造器，意味着不可以实例化。
- 5.在Java开发中，接口都让类去实现（implements）的方式来使用   如果实现类覆盖了接口中所有的抽象方法，则此实现类可以实例化。  如果没有，则此实现类仍为抽象类。
- 6.Java类可以实现多个接口-->弥补了单继承的局限性。格式：class AA extends BB implements CC,DD,EE{}
- 7.接口与接口之间可以继承，而且可以多继承
- 8.接口的具体使用体现多态性
- 9.接口，实际上可以看作是一种规范。
- **接口的使用：**
- 1.接口的使用上也满足多态性。
- 2.接口，实际上就是定义了一种规范。
- 3.开发中体会面向接口编程。

## 集合

## 反射

## 日期和时间的api

E:\ideasProjects\Projects\test\Date

